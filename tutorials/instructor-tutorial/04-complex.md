---
layout: default
title: "Instructor Tutorial - Chapter 4: Complex Structures"
nav_order: 4
has_children: false
parent: Instructor Tutorial
---

# Chapter 4: Complex Structures and Nested Data

> Model nested objects, arrays, and rich domain data without losing validation guarantees.

## Overview

Large objects and deep nesting can confuse models. Instructor plus strong schemas keep outputs predictable. You will build a nested content plan and add constraints to control size and shape.

## Nested Content Plan Example

```python
from pydantic import BaseModel, Field, HttpUrl, conint
from typing import Literal
import instructor
from openai import OpenAI

client = instructor.from_openai(OpenAI())

class Reference(BaseModel):
    title: str
    url: HttpUrl

class Section(BaseModel):
    heading: str = Field(..., description="short, actionable")
    summary: str = Field(..., max_length=280)
    bullets: list[str] = Field(..., max_items=4, description="tight bullet list")
    references: list[Reference] = Field(default_factory=list, max_items=3)

class ContentPlan(BaseModel):
    topic: str
    audience: Literal["beginner", "intermediate", "expert"]
    sections: list[Section] = Field(..., min_items=3, max_items=6)
```

```python
plan = client.responses.create(
    model="gpt-4o-mini",
    messages=[
        {
            "role": "user",
            "content": "Create a tutorial outline about building a Next.js + CopilotKit app.",
        }
    ],
    response_model=ContentPlan,
)
```

## Controlling Length and Depth

- Use `max_items` to cap arrays.
- Keep summaries short (`max_length`) and add examples in descriptions (“3 bullets, 5–10 words each”).
- Break big objects into smaller calls when needed; merge results in Python.

## Hierarchical IDs

```python
from uuid import uuid4

class Step(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid4()))
    action: str
    expected: str

class Playbook(BaseModel):
    name: str
    steps: list[Step] = Field(..., max_items=10)
```

IDs generated by `default_factory` ensure stable references without asking the LLM to invent UUIDs.

## Paginating Large Outputs

If the schema is large (e.g., 50+ items), paginate:

1. Ask for high-level structure first (headings only).
2. Request each section separately with `response_model=Section`.
3. Combine in your application code.

This reduces context size and improves accuracy.

## Validating Relationships

Use validators to enforce cross-field rules:

```python
from pydantic import model_validator

class Roadmap(BaseModel):
    quarter: str
    goals: list[str]
    risks: list[str]

    @model_validator(mode="after")
    def goals_and_risks_balanced(self):
        if len(self.risks) > len(self.goals):
            raise ValueError("risks cannot exceed goals; focus the plan")
        return self
```

Next: stream partial objects to improve user experience. 
